/*-------------------------------------------------------------------------
 - mini.q - a minimalistic multiplayer fps
 - iso.cpp -> implements routines for iso surface
 -------------------------------------------------------------------------*/
#pragma once
#include "csg.hpp"
#include "bvh.hpp"
#include "base/sys.hpp"
#include "base/task.hpp"
#include "base/vector.hpp"
#include "base/math.hpp"

namespace q {
namespace iso {
namespace voxel {

/*-------------------------------------------------------------------------
 - quad as generated by iso contouring
 -------------------------------------------------------------------------*/
struct quad {
  vec3<char> index[4];
  u32 matindex;
};

/*-------------------------------------------------------------------------
 - per-leaf octree for compact representation
 -------------------------------------------------------------------------*/
struct leafoctreebase {
  struct node {
    INLINE void setemptyleaf() {
      idx = 0;
      isleaf = empty = 1;
    }
    u32 idx:30;
    u32 isleaf:1;
    u32 empty:1;
  };
  INLINE node *getnode(int idx) { return &root[idx]; }
  INLINE u32 descend(vec3i &xyz, u32 level, u32 idx);
  void init();
  void insert(vec3i xyz, int ptidx);
  int getidx(vec3i xyz);
  vector<node> root; // root node of the leaf octree
};

template <typename T>
struct leafoctree : leafoctreebase {
  void init() {
    leafoctreebase::init();
    quads.resize(0);
    pts.resize(0);
  }
  INLINE T *get(vec3i xyz) {
    const auto idx = getidx(xyz);
    return idx == -1 ? NULL : &pts[idx];
  }
  vector<T> pts;      // qef points given by dual contouring
  vector<quad> quads; // all quads in the leaf
};

/*-------------------------------------------------------------------------
 - spatial segmentation used for iso surface extraction
 -------------------------------------------------------------------------*/
struct octree {
  struct point {
    INLINE void setasmerged() {ownerlo|=1;}
    INLINE void setptr(uintptr ptr) {
      assert(ptr % 2 == 0 && "pointer is not properly aligned");
      ownerlo = (ownerlo & 1) | u32(ptr);
#if POINTER_BYTE_SIZE == 8
      ownerhi = u32(ptr >> 32ull);
#endif
    }
    vec3f pos;   // world position (TODO relative and quantize)
    u32 ownerlo; // parent leaf or other point if collapsed with this point
#if POINTER_BYTE_SIZE == 8
    u32 ownerhi; // high part of the pointer
#endif
  };
  struct node {
    INLINE node() : children(NULL), level(0), isleaf(0), empty(0), flag(0) {}
    ~node();
    union {
      node *children;
      leafoctree<point> *leaf;
    };
    ref<rt::intersector> bvh;
    vec3i org;
    u32 level:30;
    u32 isleaf:1;
    u32 empty:1;
    u32 flag;
  };
  typedef leafoctree<point> leaftype;

  INLINE octree(u32 dim) : m_dim(dim), m_logdim(ilog2(dim)) {}
  const node *findleaf(vec3i xyz) const;
  node m_root;
  u32 m_dim, m_logdim;
  ref<rt::intersector> bvh;
};
static const int SUBGRID = 16;

// tesselate along a grid the distance field with dual contouring algorithm
ref<task> create_task(octree&, const csg::node&, const vec3f&, u32 cellnum, float cellsize);

// return the current bvh (XXX remove this global!)
ref<rt::intersector> get_bvh();

void start();
void finish();
} /* namespace voxel */
} /* namespace iso */
} /* namespace q */


