/*-------------------------------------------------------------------------
 - mini.q - a minimalistic multiplayer fps
 - iso.cpp -> implements routines for iso surface
 -------------------------------------------------------------------------*/
#pragma once
#include "csg.hpp"
#include "geom.hpp"
#include "base/sys.hpp"
#include "base/vector.hpp"
#include "base/math.hpp"

namespace q {
namespace iso {

/*-------------------------------------------------------------------------
 - quad as generated by iso contouring
 -------------------------------------------------------------------------*/
struct quad {
  vec3<char> index[4];
  u32 matindex;
};

/*-------------------------------------------------------------------------
 - per-leaf octree for compact representation
 -------------------------------------------------------------------------*/
struct leafoctreebase {
  struct node {
    INLINE void setemptyleaf() {
      idx = 0;
      isleaf = empty = 1;
    }
    u32 idx:30;
    u32 isleaf:1;
    u32 empty:1;
  };
  INLINE node *getnode(int idx) { return &root[idx]; }
  INLINE u32 descend(vec3i &xyz, u32 level, u32 idx);
  void init();
  void insert(vec3i xyz, int ptidx);
  int getidx(vec3i xyz);
  vector<node> root; // root node of the leaf octree
};

template <typename T>
struct leafoctree : leafoctreebase {
  void init() {
    leafoctreebase::init();
    quads.setsize(0);
    pts.setsize(0);
  }
  INLINE T *get(vec3i xyz) {
    const auto idx = getidx(xyz);
    return idx == -1 ? NULL : &pts[idx];
  }
  vector<T> pts;      // qef points given by dual contouring
  vector<quad> quads; // all quads in the leaf
};

/*-------------------------------------------------------------------------
 - spatial segmentation used for iso surface extraction
 -------------------------------------------------------------------------*/
struct octree {
  struct qefpoint {
    vec3f pos;
    int idx;
  };
  struct node {
    INLINE node() : children(NULL), level(0), isleaf(0), empty(0) {}
    ~node();
    union {
      node *children;
      leafoctree<qefpoint> *leaf;
    };
    vec3i org;
    u32 level:30;
    u32 isleaf:1;
    u32 empty:1;
  };
  typedef leafoctree<qefpoint> leaftype;

  INLINE octree(u32 dim) : m_dim(dim), m_logdim(ilog2(dim)) {}
  const node *findleaf(vec3i xyz) const;
  node m_root;
  u32 m_dim, m_logdim;
};
static const u32 SUBGRID = 16;

// tesselate along a grid the distance field with dual contouring algorithm
geom::mesh dc(const vec3f &org, u32 cellnum, float cellsize, const csg::node &d);

void start();
void finish();
} /* namespace iso */
} /* namespace q */

