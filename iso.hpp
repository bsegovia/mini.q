/*-------------------------------------------------------------------------
 - mini.q - a minimalistic multiplayer FPS
 - iso.hpp -> exposes common functions for both marching cubes and dual
 - contouring
 -------------------------------------------------------------------------*/
#pragma once
#include "sys.hpp"
#include "stl.hpp"
#include "math.hpp"

namespace q {
namespace iso {

// simple structure to describe meshes generated by marching cube or dual
// contouring
struct mesh {
  INLINE mesh(vec3f *pos=NULL, vec3f *nor=NULL, u32 *index=NULL, u32 vn=0, u32 idxn=0) :
    m_pos(pos), m_nor(nor), m_index(index), m_vertnum(vn), m_indexnum(idxn) {}
  ~mesh();
  vec3f *m_pos, *m_nor;
  u32 *m_index;
  u32 m_vertnum;
  u32 m_indexnum;
};

// describes a grid with a given location in the world
struct grid {
  grid(const vec3f &cellsize, const vec3f &org, const vec3i &dim) :
    m_cellsize(cellsize), m_org(org), m_dim(dim) {}
  INLINE vec3f vertex(const vec3i &p) {return m_org+m_cellsize*vec3f(p);}
  vec3f m_cellsize;
  vec3f m_org;
  vec3i m_dim;
};

INLINE pair<vec3i,u32> edge(vec3i start, vec3i end) {
  const auto lower = select(start<end, start, end);
  const auto delta = select(eq(start,end), vec3i(zero), vec3i(one));
  assert(reduceadd(delta) == 1);
  return makepair(lower, u32(delta.y+2*delta.z));
}

// helper tables for both mc and dc algorithms
extern const vec3f fcubev[8];
extern const vec3i icubev[8];
extern const u16 edgetable[256];
extern const int interptable[12][2];

// get the distance to the field from 'pos'
typedef float (*distance_field)(const vec3f &pos);

// estimate the gradient (i.e. normal vector) at the given position
static const float DEFAULT_GRAD_STEP = 1e-3f;
vec3f gradient(distance_field d, const vec3f &pos, float grad_step = DEFAULT_GRAD_STEP);

// helper macros
#define loopxy(org, end, Z)\
  for (int Y = int(org.y); Y < int(end.y); ++Y)\
  for (auto xyz = vec3i(org.x,Y,Z); xyz.x < int(end.x); ++xyz.x)
#define loopxyz(org, end) \
  for (int Z = int(org.z); Z < int(end.z); ++Z)\
  for (int Y = int(org.y); Y < int(end.y); ++Y)\
  for (auto xyz = vec3i(org.x,Y,Z); xyz.x < int(end.x); ++xyz.x)

// helper structure to build mesh slice by slice inside a regular grid
template <u32 extra, u32 slicenum>
struct slicebuilder {
  enum { NOINDEX = ~0x0u };
  INLINE slicebuilder(distance_field df, const grid &grid) :
    m_df(df), m_grid(grid), m_field(slicenum*(grid.m_dim.x+extra)*(grid.m_dim.y+extra)) {}
  void initfield(u32 z) {
    const vec2i org(zero), dim(extra+m_grid.m_dim.x, extra+m_grid.m_dim.y);
    loopxy(org, dim, z) field(xyz) = m_df(m_grid.vertex(xyz));
  }
  void resetbuffer() {
    m_pos_buffer.setsize(0);
    m_nor_buffer.setsize(0);
  }
  INLINE float &field(const vec3i &xyz) {
    const vec2i dim(extra+m_grid.m_dim.x, extra+m_grid.m_dim.y);
    const auto offset = (xyz.z%slicenum)*dim.x*dim.y;
    return m_field[offset+dim.x*xyz.y+xyz.x];
  }
  distance_field m_df;
  grid m_grid;
  vector<float> m_field;
  vector<vec3f> m_pos_buffer, m_nor_buffer;
  vector<u32> m_idx_buffer;
};

// tesselate along a grid the distance field with dual contouring algorithm
mesh dc_mesh(const grid &grid, distance_field f);

// tesselate along a grid the distance field with marching cube algorithm
mesh mc_mesh(const grid &grid, distance_field f);
} /* namespace iso */
} /* namespace q */

